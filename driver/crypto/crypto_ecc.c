/*
 * crypto.c
 *
 *  Created on: 2023/5/23
 *      Author: LAPTOP-07
 */
#include "dbg_assert.h"
#include "crypto.h"
#include <string.h>
#include <stdlib.h>

// ecc curves
const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_P192 =
{
    24, 1, 1, 0,
    {
        /* p */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        /* a */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
        /* b */
        0x64, 0x21, 0x05, 0x19, 0xE5, 0x9C, 0x80, 0xE7, 0x0F, 0xA7, 0xE9, 0xAB,
        0x72, 0x24, 0x30, 0x49, 0xFE, 0xB8, 0xDE, 0xEC, 0xC1, 0x46, 0xB9, 0xB1,
        /* x */
        0x18, 0x8D, 0xA8, 0x0E, 0xB0, 0x30, 0x90, 0xF6, 0x7C, 0xBF, 0x20, 0xEB,
        0x43, 0xA1, 0x88, 0x00, 0xF4, 0xFF, 0x0A, 0xFD, 0x82, 0xFF, 0x10, 0x12,
        /* y */
        0x07, 0x19, 0x2b, 0x95, 0xff, 0xc8, 0xda, 0x78, 0x63, 0x10, 0x11, 0xed,
        0x6b, 0x24, 0xcd, 0xd5, 0x73, 0xf9, 0x77, 0xa1, 0x1e, 0x79, 0x48, 0x11,
        /* order */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x99, 0xDE, 0xF8, 0x36, 0x14, 0x6B, 0xC9, 0xB1, 0xB4, 0xD2, 0x28, 0x31,
        /* p' */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        /* r^2 */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    }
};

const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_P224 =
{
    28, 1, 1, 0,
    {
        /* p */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01,
        /* a */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFE,
        /* b */
        0xB4, 0x05, 0x0A, 0x85, 0x0C, 0x04, 0xB3, 0xAB, 0xF5, 0x41, 0x32, 0x56,
        0x50, 0x44, 0xB0, 0xB7, 0xD7, 0xBF, 0xD8, 0xBA, 0x27, 0x0B, 0x39, 0x43,
        0x23, 0x55, 0xFF, 0xB4,
        /* x */
        0xB7, 0x0E, 0x0C, 0xBD, 0x6B, 0xB4, 0xBF, 0x7F, 0x32, 0x13, 0x90, 0xB9,
        0x4A, 0x03, 0xC1, 0xD3, 0x56, 0xC2, 0x11, 0x22, 0x34, 0x32, 0x80, 0xD6,
        0x11, 0x5C, 0x1D, 0x21,
        /* y */
        0xbd, 0x37, 0x63, 0x88, 0xb5, 0xf7, 0x23, 0xfb, 0x4c, 0x22, 0xdf, 0xe6,
        0xcd, 0x43, 0x75, 0xa0, 0x5a, 0x07, 0x47, 0x64, 0x44, 0xd5, 0x81, 0x99,
        0x85, 0x00, 0x7e, 0x34,
        /* order */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x16, 0xA2, 0xE0, 0xB8, 0xF0, 0x3E, 0x13, 0xDD, 0x29, 0x45,
        0x5C, 0x5C, 0x2A, 0x3D,
        /* p' */
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        /* r^2 */
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01
    }
};

const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_P256 =
{
    32, 1, 1, 0,
    {
        /* p */
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        /* a */
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
        /* b */
        0x5A, 0xC6, 0x35, 0xD8, 0xAA, 0x3A, 0x93, 0xE7, 0xB3, 0xEB, 0xBD, 0x55,
        0x76, 0x98, 0x86, 0xBC, 0x65, 0x1D, 0x06, 0xB0, 0xCC, 0x53, 0xB0, 0xF6,
        0x3B, 0xCE, 0x3C, 0x3E, 0x27, 0xD2, 0x60, 0x4B,
        /* x */
        0x6B, 0x17, 0xD1, 0xF2, 0xE1, 0x2C, 0x42, 0x47, 0xF8, 0xBC, 0xE6, 0xE5,
        0x63, 0xA4, 0x40, 0xF2, 0x77, 0x03, 0x7D, 0x81, 0x2D, 0xEB, 0x33, 0xA0,
        0xF4, 0xA1, 0x39, 0x45, 0xD8, 0x98, 0xC2, 0x96,
        /* y */
        0x4f, 0xe3, 0x42, 0xe2, 0xfe, 0x1a, 0x7f, 0x9b, 0x8e, 0xe7, 0xeb, 0x4a,
        0x7c, 0x0f, 0x9e, 0x16, 0x2b, 0xce, 0x33, 0x57, 0x6b, 0x31, 0x5e, 0xce,
        0xcb, 0xb6, 0x40, 0x68, 0x37, 0xbf, 0x51, 0xf5,
        /* order */
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBC, 0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84,
        0xF3, 0xB9, 0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51,
        /* p' */
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        /* r^2 mod p */
        0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

    }
};


const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_P384 =
{
    48, 1, 1, 0,
    {
        /* p */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        /* a */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFC,
        /* b */
        0xB3, 0x31, 0x2F, 0xA7, 0xE2, 0x3E, 0xE7, 0xE4, 0x98, 0x8E, 0x05, 0x6B,
        0xE3, 0xF8, 0x2D, 0x19, 0x18, 0x1D, 0x9C, 0x6E, 0xFE, 0x81, 0x41, 0x12,
        0x03, 0x14, 0x08, 0x8F, 0x50, 0x13, 0x87, 0x5A, 0xC6, 0x56, 0x39, 0x8D,
        0x8A, 0x2E, 0xD1, 0x9D, 0x2A, 0x85, 0xC8, 0xED, 0xD3, 0xEC, 0x2A, 0xEF,
        /* x */
        0xAA, 0x87, 0xCA, 0x22, 0xBE, 0x8B, 0x05, 0x37, 0x8E, 0xB1, 0xC7, 0x1E,
        0xF3, 0x20, 0xAD, 0x74, 0x6E, 0x1D, 0x3B, 0x62, 0x8B, 0xA7, 0x9B, 0x98,
        0x59, 0xF7, 0x41, 0xE0, 0x82, 0x54, 0x2A, 0x38, 0x55, 0x02, 0xF2, 0x5D,
        0xBF, 0x55, 0x29, 0x6C, 0x3A, 0x54, 0x5E, 0x38, 0x72, 0x76, 0x0A, 0xB7,
        /* y */
        0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf,
        0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c,
        0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0x0a, 0x60, 0xb1, 0xce,
        0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5f,
        /* order */
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xC7, 0x63, 0x4D, 0x81, 0xF4, 0x37, 0x2D, 0xDF, 0x58, 0x1A, 0x0D, 0xB2,
        0x48, 0xB0, 0xA7, 0x7A, 0xEC, 0xEC, 0x19, 0x6A, 0xCC, 0xC5, 0x29, 0x73,
        /* p' */
        0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0c,
        0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfa,
        0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        /* r^2 */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01,
    }
};


const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_BP512R1 =
{
    64, 1, 1, 0,
    {
        /* p */
        0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE,
        0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
        0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x71, 0x7D, 0x4D, 0x9B, 0x00,
        0x9B, 0xC6, 0x68, 0x42, 0xAE, 0xCD, 0xA1, 0x2A, 0xE6, 0xA3, 0x80, 0xE6,
        0x28, 0x81, 0xFF, 0x2F, 0x2D, 0x82, 0xC6, 0x85, 0x28, 0xAA, 0x60, 0x56,
        0x58, 0x3A, 0x48, 0xF3,
        /* a */
        0x78, 0x30, 0xA3, 0x31, 0x8B, 0x60, 0x3B, 0x89, 0xE2, 0x32, 0x71, 0x45,
        0xAC, 0x23, 0x4C, 0xC5, 0x94, 0xCB, 0xDD, 0x8D, 0x3D, 0xF9, 0x16, 0x10,
        0xA8, 0x34, 0x41, 0xCA, 0xEA, 0x98, 0x63, 0xBC, 0x2D, 0xED, 0x5D, 0x5A,
        0xA8, 0x25, 0x3A, 0xA1, 0x0A, 0x2E, 0xF1, 0xC9, 0x8B, 0x9A, 0xC8, 0xB5,
        0x7F, 0x11, 0x17, 0xA7, 0x2B, 0xF2, 0xC7, 0xB9, 0xE7, 0xC1, 0xAC, 0x4D,
        0x77, 0xFC, 0x94, 0xCA,
        /* b */
        0x3D, 0xF9, 0x16, 0x10, 0xA8, 0x34, 0x41, 0xCA, 0xEA, 0x98, 0x63, 0xBC,
        0x2D, 0xED, 0x5D, 0x5A, 0xA8, 0x25, 0x3A, 0xA1, 0x0A, 0x2E, 0xF1, 0xC9,
        0x8B, 0x9A, 0xC8, 0xB5, 0x7F, 0x11, 0x17, 0xA7, 0x2B, 0xF2, 0xC7, 0xB9,
        0xE7, 0xC1, 0xAC, 0x4D, 0x77, 0xFC, 0x94, 0xCA, 0xDC, 0x08, 0x3E, 0x67,
        0x98, 0x40, 0x50, 0xB7, 0x5E, 0xBA, 0xE5, 0xDD, 0x28, 0x09, 0xBD, 0x63,
        0x80, 0x16, 0xF7, 0x23,
        /* x */
        0x81, 0xAE, 0xE4, 0xBD, 0xD8, 0x2E, 0xD9, 0x64, 0x5A, 0x21, 0x32, 0x2E,
        0x9C, 0x4C, 0x6A, 0x93, 0x85, 0xED, 0x9F, 0x70, 0xB5, 0xD9, 0x16, 0xC1,
        0xB4, 0x3B, 0x62, 0xEE, 0xF4, 0xD0, 0x09, 0x8E, 0xFF, 0x3B, 0x1F, 0x78,
        0xE2, 0xD0, 0xD4, 0x8D, 0x50, 0xD1, 0x68, 0x7B, 0x93, 0xB9, 0x7D, 0x5F,
        0x7C, 0x6D, 0x50, 0x47, 0x40, 0x6A, 0x5E, 0x68, 0x8B, 0x35, 0x22, 0x09,
        0xBC, 0xB9, 0xF8, 0x22,
        /* y */
        0x7D, 0xDE, 0x38, 0x5D, 0x56, 0x63, 0x32, 0xEC, 0xC0, 0xEA, 0xBF, 0xA9,
        0xCF, 0x78, 0x22, 0xFD, 0xF2, 0x09, 0xF7, 0x00, 0x24, 0xA5, 0x7B, 0x1A,
        0xA0, 0x00, 0xC5, 0x5B, 0x88, 0x1F, 0x81, 0x11, 0xB2, 0xDC, 0xDE, 0x49,
        0x4A, 0x5F, 0x48, 0x5E, 0x5B, 0xCA, 0x4B, 0xD8, 0x8A, 0x27, 0x63, 0xAE,
        0xD1, 0xCA, 0x2B, 0x2F, 0xA8, 0xF0, 0x54, 0x06, 0x78, 0xCD, 0x1E, 0x0F,
        0x3A, 0xD8, 0x08, 0x92,
        /* order */
        0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE,
        0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
        0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x70, 0x55, 0x3E, 0x5C, 0x41,
        0x4C, 0xA9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7F, 0xAC, 0x10, 0x47,
        0x1D, 0xB1, 0xD3, 0x81, 0x08, 0x5D, 0xDA, 0xDD, 0xB5, 0x87, 0x96, 0x82,
        0x9C, 0xA9, 0x00, 0x69,
        /* p' */
        0x4c, 0x39, 0x8e, 0x09, 0x22, 0x96, 0x3f, 0x73, 0xc8, 0x2b, 0x46, 0xfb,
        0xfa, 0xae, 0xa0, 0x06, 0x36, 0x82, 0xa0, 0x85, 0xd4, 0xf0, 0x55, 0x03,
        0x16, 0x09, 0x8b, 0x3e, 0x75, 0xc2, 0x05, 0x72, 0xae, 0xf7, 0x52, 0x8b,
        0xc5, 0xa7, 0xe2, 0x43, 0x50, 0x65, 0x2e, 0xc0, 0x81, 0x5c, 0xfb, 0xcd,
        0xed, 0xaa, 0x1d, 0x85, 0xa2, 0xcd, 0x1e, 0x7c, 0x83, 0x9b, 0x32, 0x20,
        0x7d, 0x89, 0xef, 0xc5,
        /* r^2 */
        0x3c, 0x4c, 0x9d, 0x05, 0xa9, 0xff, 0x64, 0x50, 0x20, 0x2e, 0x19, 0x40,
        0x20, 0x56, 0xee, 0xcc, 0xa1, 0x6d, 0xaa, 0x5f, 0xd4, 0x2b, 0xff, 0x83,
        0x19, 0x48, 0x6f, 0xd8, 0xd5, 0x89, 0x80, 0x57, 0xe0, 0xc1, 0x9a, 0x77,
        0x83, 0x51, 0x4a, 0x25, 0x53, 0xb7, 0xf9, 0xbc, 0x90, 0x5a, 0xff, 0xd3,
        0x79, 0x3f, 0xb1, 0x30, 0x27, 0x15, 0x79, 0x05, 0x49, 0xad, 0x14, 0x4a,
        0x61, 0x58, 0xf2, 0x05,
    }
};

const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_BP512T1 =
{
    64, 1, 1, 0,
    {
        /* p */
        0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE,
        0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
        0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x71, 0x7D, 0x4D, 0x9B, 0x00,
        0x9B, 0xC6, 0x68, 0x42, 0xAE, 0xCD, 0xA1, 0x2A, 0xE6, 0xA3, 0x80, 0xE6,
        0x28, 0x81, 0xFF, 0x2F, 0x2D, 0x82, 0xC6, 0x85, 0x28, 0xAA, 0x60, 0x56,
        0x58, 0x3A, 0x48, 0xF3,
        /* a */
        0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE,
        0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
        0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x71, 0x7D, 0x4D, 0x9B, 0x00,
        0x9B, 0xC6, 0x68, 0x42, 0xAE, 0xCD, 0xA1, 0x2A, 0xE6, 0xA3, 0x80, 0xE6,
        0x28, 0x81, 0xFF, 0x2F, 0x2D, 0x82, 0xC6, 0x85, 0x28, 0xAA, 0x60, 0x56,
        0x58, 0x3A, 0x48, 0xF0,
        /* b */
        0x7C, 0xBB, 0xBC, 0xF9, 0x44, 0x1C, 0xFA, 0xB7, 0x6E, 0x18, 0x90, 0xE4,
        0x68, 0x84, 0xEA, 0xE3, 0x21, 0xF7, 0x0C, 0x0B, 0xCB, 0x49, 0x81, 0x52,
        0x78, 0x97, 0x50, 0x4B, 0xEC, 0x3E, 0x36, 0xA6, 0x2B, 0xCD, 0xFA, 0x23,
        0x04, 0x97, 0x65, 0x40, 0xF6, 0x45, 0x00, 0x85, 0xF2, 0xDA, 0xE1, 0x45,
        0xC2, 0x25, 0x53, 0xB4, 0x65, 0x76, 0x36, 0x89, 0x18, 0x0E, 0xA2, 0x57,
        0x18, 0x67, 0x42, 0x3E,
        /* x */
        0x64, 0x0E, 0xCE, 0x5C, 0x12, 0x78, 0x87, 0x17, 0xB9, 0xC1, 0xBA, 0x06,
        0xCB, 0xC2, 0xA6, 0xFE, 0xBA, 0x85, 0x84, 0x24, 0x58, 0xC5, 0x6D, 0xDE,
        0x9D, 0xB1, 0x75, 0x8D, 0x39, 0xC0, 0x31, 0x3D, 0x82, 0xBA, 0x51, 0x73,
        0x5C, 0xDB, 0x3E, 0xA4, 0x99, 0xAA, 0x77, 0xA7, 0xD6, 0x94, 0x3A, 0x64,
        0xF7, 0xA3, 0xF2, 0x5F, 0xE2, 0x6F, 0x06, 0xB5, 0x1B, 0xAA, 0x26, 0x96,
        0xFA, 0x90, 0x35, 0xDA,
        /* y */
        0x5B, 0x53, 0x4B, 0xD5, 0x95, 0xF5, 0xAF, 0x0F, 0xA2, 0xC8, 0x92, 0x37,
        0x6C, 0x84, 0xAC, 0xE1, 0xBB, 0x4E, 0x30, 0x19, 0xB7, 0x16, 0x34, 0xC0,
        0x11, 0x31, 0x15, 0x9C, 0xAE, 0x03, 0xCE, 0xE9, 0xD9, 0x93, 0x21, 0x84,
        0xBE, 0xEF, 0x21, 0x6B, 0xD7, 0x1D, 0xF2, 0xDA, 0xDF, 0x86, 0xA6, 0x27,
        0x30, 0x6E, 0xCF, 0xF9, 0x6D, 0xBB, 0x8B, 0xAC, 0xE1, 0x98, 0xB6, 0x1E,
        0x00, 0xF8, 0xB3, 0x32,
        /* order */
        0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE,
        0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
        0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x70, 0x55, 0x3E, 0x5C, 0x41,
        0x4C, 0xA9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7F, 0xAC, 0x10, 0x47,
        0x1D, 0xB1, 0xD3, 0x81, 0x08, 0x5D, 0xDA, 0xDD, 0xB5, 0x87, 0x96, 0x82,
        0x9C, 0xA9, 0x00, 0x69,
        /* p' */
        0x4c, 0x39, 0x8e, 0x09, 0x22, 0x96, 0x3f, 0x73, 0xc8, 0x2b, 0x46, 0xfb,
        0xfa, 0xae, 0xa0, 0x06, 0x36, 0x82, 0xa0, 0x85, 0xd4, 0xf0, 0x55, 0x03,
        0x16, 0x09, 0x8b, 0x3e, 0x75, 0xc2, 0x05, 0x72, 0xae, 0xf7, 0x52, 0x8b,
        0xc5, 0xa7, 0xe2, 0x43, 0x50, 0x65, 0x2e, 0xc0, 0x81, 0x5c, 0xfb, 0xcd,
        0xed, 0xaa, 0x1d, 0x85, 0xa2, 0xcd, 0x1e, 0x7c, 0x83, 0x9b, 0x32, 0x20,
        0x7d, 0x89, 0xef, 0xc5,
        /* r^2 */
        0x3c, 0x4c, 0x9d, 0x05, 0xa9, 0xff, 0x64, 0x50, 0x20, 0x2e, 0x19, 0x40,
        0x20, 0x56, 0xee, 0xcc, 0xa1, 0x6d, 0xaa, 0x5f, 0xd4, 0x2b, 0xff, 0x83,
        0x19, 0x48, 0x6f, 0xd8, 0xd5, 0x89, 0x80, 0x57, 0xe0, 0xc1, 0x9a, 0x77,
        0x83, 0x51, 0x4a, 0x25, 0x53, 0xb7, 0xf9, 0xbc, 0x90, 0x5a, 0xff, 0xd3,
        0x79, 0x3f, 0xb1, 0x30, 0x27, 0x15, 0x79, 0x05, 0x49, 0xad, 0x14, 0x4a,
        0x61, 0x58, 0xf2, 0x05,
    }
};

const CRYPTO_ECC_CURVE CRYPTO_ECC_CURVE_SM2P256 =
{
    32, 1, 1, 0,
    {
        /* p */
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        /* a */
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
        /* b */
        0x28, 0xe9, 0xfa, 0x9e, 0x9d, 0x9f, 0x5e, 0x34, 0x4d, 0x5a, 0x9e, 0x4b,
        0xcf, 0x65, 0x09, 0xa7, 0xf3, 0x97, 0x89, 0xf5, 0x15, 0xab, 0x8f, 0x92,
        0xdd, 0xbc, 0xbd, 0x41, 0x4d, 0x94, 0x0e, 0x93,
        /* x */
        0x32, 0xc4, 0xae, 0x2c, 0x1f, 0x19, 0x81, 0x19, 0x5f, 0x99, 0x04, 0x46,
        0x6a, 0x39, 0xc9, 0x94, 0x8f, 0xe3, 0x0b, 0xbf, 0xf2, 0x66, 0x0b, 0xe1,
        0x71, 0x5a, 0x45, 0x89, 0x33, 0x4c, 0x74, 0xc7,
        /* y */
        0xbc, 0x37, 0x36, 0xa2, 0xf4, 0xf6, 0x77, 0x9c, 0x59, 0xbd, 0xce, 0xe3,
        0x6b, 0x69, 0x21, 0x53, 0xd0, 0xa9, 0x87, 0x7c, 0xc6, 0x2a, 0x47, 0x40,
        0x02, 0xdf, 0x32, 0xe5, 0x21, 0x39, 0xf0, 0xa0,
        /* order */
        0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x72, 0x03, 0xdf, 0x6b, 0x21, 0xc6, 0x05, 0x2b,
        0x53, 0xbb, 0xf4, 0x09, 0x39, 0xd5, 0x41, 0x23,
        /* p' */
        0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        /* r^2 */
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03
    }
};

enum ecc_program_entry
{
    ECC_ENRTY_MMULT     = 0x0a,
    ECC_ENRTY_MADD      = 0x0b,
    ECC_ENRTY_MSUB      = 0x0c,
    ECC_ENRTY_MDIV      = 0x0d,
    ECC_ENRTY_MINV      = 0x0e,
    ECC_ENRTY_MOD       = 0x0f,
    ECC_ENRTY_MP        = 0x10,
    ECC_ENRTY_RI        = 0x11,
    ECC_ENRTY_R2        = 0x12,
    ECC_ENRTY_PMULT     = 0x13,
    ECC_ENRTY_PDBL      = 0x14,
    ECC_ENRTY_PADD      = 0x16,
    ECC_ENRTY_PVER      = 0x18,

};

#define write_mem(addr,value)  *((uint32_t*)(addr))=(value)
#define save_mem(addr,value)    (value)=*((uint32_t*)(addr))

#define ECC_REG_A0_OFFSET        0x0400
#define ECC_REG_B0_OFFSET        0x0800
#define ECC_REG_C0_OFFSET        0x0C00
#define ECC_REG_D0_OFFSET        0x1000

#define CRYPTO_ECC_BUFF_SIZE        (CRYPTO_ECC_MAX_LEN/32)

static uint32_t crypto_ecc_temp_buff[CRYPTO_ECC_BUFF_SIZE*2];

// ecc functions
// internal functions
static uint32_t crypto_ecc_swap32(uint32_t val32)
{
    return (val32<<24) | ((val32<<8)&0xFF0000) | ((val32>>8)&0xFF00) | ((val32>>24)&0xFF);
}

static void crypto_ecc_write_block(CRYPTO_RESOURCES *crypto, uint32_t addr, const uint32_t *data, uint32_t length)
{
    uint32_t buff[16];

    if(crypto->info->little_endian == 0)
    {
        CRYPTO_SWAP_Bytes((void*)crypto, data, length*4, buff);

        for(int i=0;i<length;i++)
            write_mem(addr+i*4, buff[i]);
    }
    else
    {
        for(int i=0;i<length;i++)
            write_mem(addr+i*4, data[i]);
    }
}

static void crypto_ecc_copy_mem(CRYPTO_RESOURCES *crypto, uint32_t to, uint32_t from, uint32_t length)
{
    uint32_t *target = (uint32_t*)to;
    uint32_t *source = (uint32_t*)from;

    for(int i=0; i<length; i++)
        target[i] = source[i];
}

static int crypto_ecc_comp_mem(CRYPTO_RESOURCES *crypto, uint32_t *target, uint32_t *source, uint32_t length)
{
    int result = 0;
    for(int i=length-1; i>=0; i--)
    {
        uint32_t a = crypto_ecc_swap32(target[i]);
        uint32_t b = crypto_ecc_swap32(source[i]);
        if(b > a)
        {
            result = 1;
            break;
        }
        if(b < a)
        {
            result = -1;
            break;
        }
    }
    return result;
}

static void crypto_ecc_load_curve(CRYPTO_RESOURCES *crypto, const CRYPTO_ECC_CURVE *curve)
{
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    int reg_size = curve->param_len>32?64:32;
    uint32_t *param = (uint32_t*)curve->param;
    int param_len = curve->param_len / 4;
    int i;

    // for test
//    for(i=0x400;i<0x1800;i+=4)
//    {
//        write_mem(ecc_base+i, i);
//    }

    // load p to D0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET, param, param_len);
    // load p' to D1
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET+reg_size, param+param_len*6, param_len);
    // load r^2 to D3
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET+reg_size*3, param+param_len*7, param_len);
    // load a to A6
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*6, param+param_len, param_len);
    // load b to A7
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*7, param+param_len*2, param_len);
}

static int32_t crypto_ecc_save_result(CRYPTO_RESOURCES *crypto, uint32_t *result, uint32_t param_len)
{
    // save result
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    ECC_INFO *ecc_info = crypto->ecc_info;
    uint32_t r_base = 0;
    int reg_size = param_len>8?64:32;
    uint32_t res = CSK_DRIVER_OK;
    int i;

    switch(ecc_info->entry)
    {
    case ECC_ENRTY_MMULT:
    case ECC_ENRTY_MADD:
    case ECC_ENRTY_MSUB:
    case ECC_ENRTY_MOD:
        // A0
        r_base = ecc_base+ECC_REG_A0_OFFSET;
        break;
    case ECC_ENRTY_MDIV:
    case ECC_ENRTY_MINV:
        // C0
        r_base = ecc_base+ECC_REG_C0_OFFSET;
        break;
    case ECC_ENRTY_PMULT:
    case ECC_ENRTY_PDBL:
    case ECC_ENRTY_PADD:
        // A2
        r_base = ecc_base+ECC_REG_A0_OFFSET+reg_size*2;
        break;
    case ECC_ENRTY_PVER:
        if(crypto->ecc_reg->REG_ELP_CLUE_RET_CODE.bit.RC_ZERO != 1)
            res = CSK_CRYPTO_ERROR_VERIFY;
        break;
    default:
        break;
    }
    if(r_base != 0)
    {
        // save data
        for(i=0;i<param_len;i++)
            save_mem(r_base+i*4, result[i]);
        if(crypto->info->little_endian == 0)
            CRYPTO_SWAP_Bytes((void*)crypto, result, param_len*4, result);

        // save point.y
        if(ecc_info->entry >= ECC_ENRTY_PMULT)
        {
            for(i=0;i<param_len;i++)
                save_mem(ecc_base+ECC_REG_B0_OFFSET+reg_size*2+i*4, result[param_len+i]);
            if(crypto->info->little_endian == 0)
                CRYPTO_SWAP_Bytes((void*)crypto, result+param_len, param_len*4, result+param_len);
        }
    }
    return res;
}


static int32_t crypto_ecc_start(CRYPTO_RESOURCES *crypto, int entry, int size)
{
    union CRYPTO_ECC_REG_ELP_CLUE_CNTL    ctrl_reg;

    crypto->ecc_reg->REG_ELP_CLUE_CONFIG.bit.CFG_ENDIAN_BYTE_SWAP = 0;
    crypto->ecc_reg->REG_ELP_CLUE_FLAGS.all = 0;
    crypto->ecc_reg->REG_ELP_CLUE_STACK.all = 0;
    crypto->ecc_reg->REG_ELP_CLUE_NEXT_FETCH.all = entry;
    crypto->ecc_reg->REG_ELP_CLUE_IE.bit.IE_IRQ_EN = 1;
    ctrl_reg.all = 0;
    ctrl_reg.bit.CTRL_BASE_RADIX = size>8?3:2;
    ctrl_reg.bit.CTRL_PARTIAL_RADIX = (size==8||size==16)?0:size;
    ctrl_reg.bit.CTRL_GO = 1;
    crypto->ecc_reg->REG_ELP_CLUE_CNTL.all = ctrl_reg.all;

    crypto->ecc_info->entry = entry;
    crypto->ecc_info->param_len = size;

    crypto->info->cb_event(CSK_CRYPTO_EVENT_WAIT_DONE, CSK_DRIVER_OK, NULL);

    return 0;
}


static void crypto_ecc_calc_ri(CRYPTO_RESOURCES *crypto, int param_len, const uint32_t *p)
{
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    ECC_INFO *ecc_info = crypto->ecc_info;
    int i;

    // load p to D0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET, p, param_len);

    crypto_ecc_start(crypto, ECC_ENRTY_RI, param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_MP, param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_R2, param_len);

}

// API functions
// calculate r = a op b mode n
int32_t
CRYPTO_Mod_Operate(void *res, uint8_t op, uint8_t num_bytes, uint32_t *r, const uint32_t *a, const uint32_t *b, const uint32_t *n)
{
    CHECK_RESOURCES(res);
    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;

    if(CRYPTO_MOD_EXP == op)
        return crypto_mod_exp(crypto, r, NULL, a, num_bytes, b, num_bytes, n, num_bytes);
    if(r==NULL || a == NULL || n == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;
    if(b==NULL && (op != CRYPTO_MOD_MOD && op != CRYPTO_MOD_INV))
        return CSK_DRIVER_ERROR_PARAMETER;

    int ecc_base = (int)crypto->ecc_reg;
    int param_len = (num_bytes+3) / 4;
    int i;
    int a_base = 0, b_base = 0;

    //crypto->ecc_info->r = r;
    crypto->ecc_info->param_len = param_len;

    if(op == CRYPTO_MOD_MULT)
    {
        // calc ~n, first r'
        crypto_ecc_calc_ri(crypto, param_len, n);

        // load a to A0
        crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET, a, param_len);
        // load b to B0
        crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET, b, param_len);

        crypto_ecc_start(crypto, ECC_ENRTY_MMULT, param_len);
        crypto_ecc_save_result(crypto, r, param_len);

        return CSK_DRIVER_OK;
    }

    // load n to D0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET, n, param_len);

    switch(op)
    {
        case CRYPTO_MOD_ADD:
        case CRYPTO_MOD_SUB:
            // load a to A0
            a_base = ecc_base+ECC_REG_A0_OFFSET;
            // load b to B0
            b_base = ecc_base+ECC_REG_B0_OFFSET;
            break;
        case CRYPTO_MOD_DIV:
            // load a to A0
            a_base = ecc_base+ECC_REG_A0_OFFSET;
            // load b to C0
            b_base = ecc_base+ECC_REG_C0_OFFSET;
            break;
        case CRYPTO_MOD_INV:
            // load a to A0
            a_base = ecc_base+ECC_REG_A0_OFFSET;
            break;
        case CRYPTO_MOD_MOD:
            // load a to C0
            a_base = ecc_base+ECC_REG_C0_OFFSET;
            break;
        default:
            return CSK_DRIVER_ERROR_PARAMETER;
            break;
    }

    crypto_ecc_write_block(crypto, a_base, a, param_len);
    if(b_base !=0)
    {
        crypto_ecc_write_block(crypto, b_base, b, param_len);
    }

    crypto_ecc_start(crypto, op-CRYPTO_MOD_MULT+ECC_ENRTY_MMULT, param_len);
    crypto_ecc_save_result(crypto, r, param_len);

    return CSK_DRIVER_OK;
}

int32_t
CRYPTO_ECC_Build_Curve(void *res, CRYPTO_ECC_CURVE *curve)
{
    CHECK_RESOURCES(res);
    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    crypto->ecc_info->curve = curve;

    if(curve->param_flag == 0)
    {
        // save result address
        uint32_t* r = (uint32_t*)(curve->param);

        // calc ~n, first r'
        crypto_ecc_calc_ri(crypto, curve->param_len/4, (uint32_t*)curve->param);

        //const CRYPTO_ECC_CURVE *curve = ecc_info->curve;
        uint32_t ecc_base = (uint32_t)crypto->ecc_reg;

        int param_len = curve->param_len / 4;
        int reg_size = curve->param_len>32?64:32;
        int i;
        // save result, end process
        // save p' from D1
        for(i=0;i<param_len;i++)
            save_mem(ecc_base+ECC_REG_D0_OFFSET+reg_size+i*4, r[param_len*6+i]);
        if(crypto->info->little_endian == 0)
            CRYPTO_SWAP_Bytes((void*)crypto, r + param_len*6, param_len*4, r + param_len*6);
        // save r^2 from D3
        for(i=0;i<param_len;i++)
            save_mem(ecc_base+ECC_REG_D0_OFFSET+reg_size*3+i*4, r[param_len*7+i]);
        if(crypto->info->little_endian == 0)
            CRYPTO_SWAP_Bytes((void*)crypto, r + param_len*7, param_len*4, r + param_len*7);
    }

    return CSK_DRIVER_OK;
}

int32_t
CRYPTO_ECC_Generate_Key(void *res, uint32_t seed, uint32_t *priv_key, uint32_t *public_key)
{
    CHECK_RESOURCES(res);

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    const CRYPTO_ECC_CURVE *curve = crypto->ecc_info->curve;

    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    int param_len = curve->param_len / 4;
    int i;

    // generate private key
    if(seed !=0 )
        srand(seed);
    for(i=0;i<param_len;i++)
    {
        priv_key[i] = rand();
    }

    // check private key
    uint32_t *order = (uint32_t*)(curve->param+curve->param_len*5);
    if(priv_key[0] >= order[0])
        priv_key[0] %= order[0];

    // calculate public key
    CRYPTO_ECC_Multiply(res, public_key, NULL, priv_key);

    return CSK_DRIVER_OK;
}

int32_t
CRYPTO_ECC_Verify_Key(void *res, const uint32_t *point)
{
    CHECK_RESOURCES(res);

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    const CRYPTO_ECC_CURVE *curve = crypto->ecc_info->curve;

    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    int param_len = curve->param_len / 4;
    int reg_size = curve->param_len>32?64:32;
    int i;


    crypto_ecc_load_curve(crypto, curve);

    // load x to A2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, point, param_len);
    // load y to B2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*2, point+param_len, param_len);

    return crypto_ecc_start(crypto, ECC_ENRTY_PVER, param_len);
}

// calculate result = P * k, if P == NULL, use G * k, if k == NULL, use efuse ecc key
int32_t
CRYPTO_ECC_Multiply(void *res, uint32_t *result, const uint32_t *p, const uint32_t *k)
{
    CHECK_RESOURCES(res);

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    const CRYPTO_ECC_CURVE *curve = crypto->ecc_info->curve;

    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    int param_len = curve->param_len / 4;
    int reg_size = curve->param_len>32?64:32;
    int i;

    if(p==NULL)
        p = (uint32_t*)(curve->param + 3 * curve->param_len);

    crypto_ecc_load_curve(crypto, curve);

    // load x to A2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, p, param_len);
    // load y to B2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*2, p + param_len, param_len);
    // load k to D7
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET+reg_size*7, k, param_len);
    if(param_len*4<reg_size)
    {
        volatile uint32_t *pD7 = (volatile uint32_t *)(ecc_base+ECC_REG_D0_OFFSET+reg_size*7);
        // fill D7 with 0
        for(int i=param_len; i<reg_size/4; i++)
            pD7[i] = 0;
    }

    // save result address
    //crypto->ecc_info->r = result;

    crypto_ecc_start(crypto, ECC_ENRTY_PMULT, param_len);
    crypto_ecc_save_result(crypto, result, param_len);

    return CSK_DRIVER_OK;
}

int32_t
CRYPTO_ECC_Add(void *res, uint32_t *result, const uint32_t *p1, const uint32_t *p2)
{
    CHECK_RESOURCES(res);

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    uint32_t ecc_base = (uint32_t)crypto->ecc_reg;
    const CRYPTO_ECC_CURVE *curve = crypto->ecc_info->curve;

    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    int param_len = curve->param_len / 4;
    int reg_size = curve->param_len>32?64:32;
    int i;

    crypto_ecc_load_curve(crypto, curve);

    // load x1 to A2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, p1, param_len);
    // load y1 to B2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*2, p1 + param_len, param_len);
    // load x2 to A3
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*3, p2, param_len);
    // load y2 to B3
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*3, p2 + param_len, param_len);

    // save result address
    //crypto->ecc_info->r = result;

    crypto_ecc_start(crypto, ECC_ENRTY_PADD, param_len);
    crypto_ecc_save_result(crypto, result, param_len);

    return CSK_DRIVER_OK;
}


int32_t
CRYPTO_ECSDA_Verify_Signature(void *res, const uint32_t *hash, const uint32_t *pub_key, const uint32_t *sign)
{
    CHECK_RESOURCES(res);
    if(hash==NULL || pub_key == NULL || sign == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    CRYPTO_RESOURCES* crypto = (CRYPTO_RESOURCES*)res;
    const CRYPTO_ECC_CURVE *curve = crypto->ecc_info->curve;
    ECC_INFO *ecc_info = crypto->ecc_info;

    if(curve == NULL)
        return CSK_DRIVER_ERROR_PARAMETER;

    int ecc_base = (int)crypto->ecc_reg;
    int param_len = curve->param_len / 4;
    int reg_size = curve->param_len>32?64:32;
    int i;
    int32_t result = CSK_DRIVER_OK;

    // save params
    crypto->ecc_info->param_len = param_len;

    // load order to D0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET, (uint32_t*)(curve->param + curve->param_len*5), param_len);
    // load s to A0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET, sign + param_len, param_len);

    // load h to C0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_C0_OFFSET, hash, param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_MDIV, param_len);

    // save C0
    crypto_ecc_copy_mem(crypto, (uint32_t)crypto_ecc_temp_buff, ecc_base+ECC_REG_C0_OFFSET, param_len);
    // load s to A0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET, sign+param_len, param_len);

    // load r to C0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_C0_OFFSET, sign, param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_MDIV, param_len);

    crypto_ecc_load_curve(crypto, curve);

    // load x to A2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, pub_key, param_len);
    // load y to B2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*2, pub_key + param_len, param_len);
    // copy C0 to D7
    crypto_ecc_copy_mem(crypto, ecc_base+ECC_REG_D0_OFFSET+reg_size*7, ecc_base+ECC_REG_C0_OFFSET, param_len);

    crypto_ecc_start(crypto, ECC_ENRTY_PMULT, param_len);

    uint32_t *p = (uint32_t*)(curve->param + 3 * curve->param_len);

    // copy 0x700 to D7
    crypto_ecc_copy_mem(crypto, ecc_base+ECC_REG_D0_OFFSET+reg_size*7, (uint32_t)crypto_ecc_temp_buff, param_len);
    // save x
    crypto_ecc_copy_mem(crypto, (uint32_t)crypto_ecc_temp_buff, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, param_len);
    // save y
    crypto_ecc_copy_mem(crypto, (uint32_t)(crypto_ecc_temp_buff + CRYPTO_ECC_BUFF_SIZE), ecc_base+ECC_REG_B0_OFFSET+reg_size*2, param_len);
    // load x to A2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, p, param_len);
    // load y to B2
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*2, p + param_len, param_len);

    crypto_ecc_start(crypto, ECC_ENRTY_PMULT, param_len);

    // load (x) to A3
    crypto_ecc_copy_mem(crypto, ecc_base+ECC_REG_A0_OFFSET+reg_size*3, (uint32_t)crypto_ecc_temp_buff, param_len);
    // load (y) to B3
    crypto_ecc_copy_mem(crypto, ecc_base+ECC_REG_B0_OFFSET+reg_size*3, (uint32_t)(crypto_ecc_temp_buff+CRYPTO_ECC_BUFF_SIZE), param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_PADD, param_len);


    // copy A2(x) to C0
    crypto_ecc_copy_mem(crypto, ecc_base+ECC_REG_C0_OFFSET, ecc_base+ECC_REG_A0_OFFSET+reg_size*2, param_len);
    // load order to D0
    crypto_ecc_write_block(crypto, ecc_base+ECC_REG_D0_OFFSET, (uint32_t*)(curve->param + curve->param_len*5), param_len);
    crypto_ecc_start(crypto, ECC_ENRTY_MOD, param_len);

    uint32_t buff[16];
    if(crypto->info->little_endian == 0)
        CRYPTO_SWAP_Bytes((void*)crypto, sign, param_len*4, buff);
    else
        memcpy(buff, sign, param_len*4);

    // compare A0 with sign
    if(crypto_ecc_comp_mem(crypto, (uint32_t*)(ecc_base+ECC_REG_A0_OFFSET), buff, param_len)!=0)
        result = CSK_CRYPTO_ERROR_VERIFY;

    return result;
}

int32_t crypto_ecc_select_curve(CRYPTO_RESOURCES *crypto, CRYPTO_ECC_CURVE *p_curve)
{
    crypto->ecc_info->curve = p_curve;

    return CSK_DRIVER_OK;
}

void crypto_ecc_irq_handler(CRYPTO_RESOURCES *crypto)
{
    uint32_t res = CSK_DRIVER_OK;
    ECC_INFO *ecc_info = crypto->ecc_info;
    LOGD("[%s]: entry=0x%x\r\n", __func__,
             ecc_info->entry);

    // clear irq
    crypto->ecc_reg->REG_ELP_CLUE_STAT.bit.STAT_IRQ = 1;

    // check stack point
    if(crypto->ecc_reg->REG_ELP_CLUE_STACK.bit.FSTACK_POINTER != 0)
    {
        res = CSK_CRYPTO_ERROR_HARDWARE;
    }
    // check stop reason
    if((crypto->ecc_reg->REG_ELP_CLUE_RET_CODE.all & CRYPTO_ECC_ELP_CLUE_RET_CODE_RC_STOP_REASON_Msk) != 0)
    {
        res = CSK_CRYPTO_ERROR_HARDWARE;
    }
    // check status
    if(crypto->ecc_reg->REG_ELP_CLUE_STAT.bit.STAT_IRQ != 0)
    {
        res = CSK_CRYPTO_ERROR_HARDWARE;
    }
    if(crypto->info->cb_event)
        crypto->info->cb_event(CSK_CRYPTO_EVENT_DONE, res, (void*)crypto);
}
